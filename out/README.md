# Instructions
Complete the code in the `bubblesort.dfy` and `*.py` files according to the
writeup PDF.

## Dafny
To complete the Dafny part of this assignment, you should finish the code in
`bubblesort.dfy` and place your answers in `written-answers.pdf` following the directions in the writeup PDF. There are two
options for running Dafny:

1. Use the online Dafny editor/interpreter at https://rise4fun.com/Dafny/1xSS
   This link is pre-populated with the starter BubbleSort code, but you'll still
   have to modify `bubblesort.dfy` after you get it working to complete the
   assignment. Note that the online version is a bit slow, and can take several
   seconds or a few minutes to execute each time.

2. Download [Dafny](https://github.com/dafny-lang/dafny) and run it
   locally. There are precompiled binaries: note that they require .NET (or
   [Mono](https://www.mono-project.com/)) to run.

The Dafny GitHub page has [a collection of links to Dafny
resources](https://github.com/dafny-lang/dafny#read-more).

## Concolic Execution

The objective of this assignment is to concolically execute the following four programs:
* `signed.py`
* `f1.py`
* `f2.py`
* `sum.py`

The result should be the number of distinct feasible program paths that were executed,
and whether not a bug was found in the subject program; that is, whether or not one of 
the inputs generated by concolic execution caused an assertion violation.

The file `test.py` contains the code to run these four tests and check the expected number
of paths and bug outcome.

In particular, you have already been provided with a full concolic execution driver in
`concolic.py`, which executes a subject program, gets back constraints, invokes a SAT/SMT solver,
figures out the next path to execute, and keeps doing this until all feasible paths are exhausted.
However, we do not have an instrumentation engine that collects constraints for subject programs.

In this assignment, you will simulate the instrumentation engine by hard-coding logic within the 
subject programs to collect path constraints on behalf of the concolic execution engine. Once you
add the proper constraint-collecting logic, the engine will be able to successfully execute all
paths and report bugs if any are found.

### Setup

To run the python code you'll need Python 3.7+ and Z3 bindings.

1. After installing Python 3, use `pip` (or `pip3`, depending on your local
   setup) to install the package `z3-solver` (i.e., `pip3 install z3-solver`).
2. Verify the integrity of your programs with `python3 integrity.py`. You should
   get no error messages and no other output. 
3. Check your setup by running the tests with `python3 test.py`. 
   You should see only 1 of 4 tests passing.

### Files and sample

The file `concolic.py` contains the concolic execution engine. You do NOT need to modify anything
in this file to pass the tests. Feel free to read through it to understand how concolic execution works.
We also encourage you to add print/debug statements in this file if it helps you pass your tests. However,
this file will not be part of your submission (or be ignored if you submit it). Instructors will use a stock
copy of `concolic.py` and `test.py` to grade your assignment.

Your submission will consist of the files `signed.py`, `f1.py`, `f2.py`, and `sum.py`, which are the four
subject programs which we are concolically testing. `signed.py` is already fully instrumented, so you don't need
to modify that either. You can run `grep -v concolic signed.py` to see what the original program looked like.
`f1.py` has a couple of constraints added by the instructors to get you started; you need
to fill in the rest, essentially "instrumenting" the program by hand. `f2.py` and `sum.py` are completely empty: 
you have to fill out all the instrumentation.

When you run `python3 test.py` for the first time, you should see the following output:
```


####### Test signed #######

Running with inputs {'x': 0}
... Path collected: [Not(x < 0), x >= 0]
... Negating the condition at line 23....
...... New candidate path: [Not(x < 0), Not(x >= 0)]
...... UNSAT!
... Negating the condition at line 15....
...... New candidate path: [Not(Not(x < 0))]
...... SAT! New inputs are: {'x': -1}

Running with inputs {'x': -1}
... Path collected: [x < 0, -x >= 0]
... Negating the condition at line 23....
...... New candidate path: [x < 0, Not(-x >= 0)]
...... UNSAT!
Concolic execution complete! 2 paths explored.



####### Test f1 #######

Running with inputs {'x': 0, 'z': 0}
... Path collected: [True]
... Negating the condition at line 18....
...... New candidate path: [Not(True)]
...... UNSAT!
Concolic execution complete! 1 paths explored.



####### Test f2 #######

Running with inputs {'a': 0, 'b': 0, 'c': 0}
... Path collected: []
Concolic execution complete! 1 paths explored.



####### Test sum #######

Running with inputs {'x': 0}
... Path collected: []
Concolic execution complete! 1 paths explored.
--------
1 tests passed.
```

See how the test for `signed` passes because each concrete execution results in collecting a proper path constraint?
For the other files the execution does not explore all expected paths because the instrumentation is missing. 

### Submission

First, run `python3 integrity.py` to make sure that your instrumentation has not altered the existing program logic.
If you see any errors, it means you have changed the meaning of the subject programs. 

Then, run `python3 test.py` to make sure you are passing the required tests (max is 4, which includes the one that
was already passing).

Finally, submit your repository to GitHub classroom. The instructors will only use your subject programs.


### Guidance

#### API and Debugging

The concolic execution engine exposes an API, of which three functions are very important:
* `concolic.guard(g:z3_expr)` -- Adds a new guard `g` to the current path constraint
* `concolic.get(x:str)` -- Gets the value for `x` from the current symbolic store
* `concolic.set(x:str, e:z3_expr|int)` -- Sets the value of `x` in the current symbolic store

For debugging, the engine also provides:
* `concolic.dump_path()`-- Prints the current symbolic path constraint to stdout

When running tests, make sure to read the output in detail, as this will tell you what path constraints
were received by the concolic engine for each run, what the inputs were, what new constraints the
engine is trying to solve, and what discrepancies it sees if any.

#### Soundness

All of the provided tests can be completely and soundly executed using concolic execution. 
If you see any `ConcolicException` for unsoundness, it means that you have collected incorrect path constraints,
which leads the execution engine to take an unexpected path. Read through the output carefully to see if the
path constraints are as you expect them to be for your subject programs.
